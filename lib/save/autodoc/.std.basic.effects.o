#/obj/handlers/autodoc/autodoc_file.c
public_functions (["submit_ee2":({({"varargs","void",}),({({"int",}),"enum",({"mixed",}),"fun",({"mixed",}),"interval",({"int",}),"flags",({"mixed",}),"event_args",}),(["main":({"This submits an effect event for a specific effect.Apart from this it is the same as submit_ee()",}),"param":({"enum the enum of the effecrt","fun the function to call","interval the interval specifier","flags the flagds associated with the event","event_args additional (optional) args passed to fun",}),]),}),"expected_tt":({({"int",}),({({"int",}),"flag",({"int",}),"new_enum",}),(["main":({"This method returns the time until any EE_REMOVE effectis expected to occur.  It will return --1 if no removeevent is scheduled.  If the flag is notset to true, the the current enum is checked, otherwisethe new_enum is checked.",}),"see":({"submit_ee()","add_effect()","expected_ee()","all_expected_ees()",}),"param":({"flag itrue, use new_enum not current_enum",}),"return":({"the time until the remove event will occur",}),]),}),"affected_object":({({"object",}),({}),(["main":({"This method returns the outer most shadow on this object.  This is usefulfor making sure functions get calklked right through the shadowlist.  If there are no objects being shadows, this_object()is returned.",}),"return":({"the outermost shadow object",}),]),}),"arg_of":({({"mixed",}),({({"int",}),"enum",}),(["main":({"This method returns the current argument associated with thegiven effect number.",}),"see":({"add_effect()","set_arg_of()","sid_to_enum()",}),"param":({"enum the effect number",}),"return":({"the argument associated with the effect",}),]),}),"enum_to_sid":({({"int",}),({({"int",}),"enum",}),(["main":({"This method turns an effect number into an effect id.",}),"param":({"enum the effect number",}),"see":({"sid_to_enum()","add_effect()",}),"return":({"the effect id",}),]),}),"set_arg_of":({({"void",}),({({"int",}),"enum",({"mixed",}),"newarg",}),(["main":({"This sets the argument of the given effect to a new value.",}),"see":({"sid_to_enum()","arg_of()","add_effect()",}),"param":({"enum the effect number to change","newarg the new argument value",}),]),}),"set_logging_effects":({({"void",}),({({"int",}),"i",}),([]),}),"effects_desting":({({"void",}),({}),(["main":({"Called when an object is dested.  Calls the desting method onall the effects.",}),]),}),"submit_ee":({({"varargs","void",}),({({"mixed",}),"fun",({"mixed",}),"interval",({"int",}),"flags",({"mixed",}),"event_args",}),(["main":({"This submits an effect event schedule.  It will call \"function name\" in youreffect object after the interval specified in interval_spec, with behaviourmodified by flags.  Addtional args may optionally be sent to \"function name\"as well.  If none are passed, args == 0.interval_spec can be one of:<dl><dt>n<dd>time in seconds<dt>({ m, n })<dd>minimum time m seconds, maximum time n seconds, simple random    distribution<dt>({ m, n, r })<dd>as for the ({ m, n }) case, except the random factor is effectively    \"rolled\" r times ... the higher r is, the more likely the interval    is to be close to (m + n)/2.</dl>flags may be:<dl><dt>EE_REMOVE<dd> remove the effect from the player aftert the function call<dt>EE_CONTINUOUS<dd>do it repeatedly.  Default (EE_ONCE) is only do it once.<dt>EE_ONCE<dd>do it once</dl>These are defined in /include/effect.h<p>Only one EE_REMOVE can be in place at a time.  Subsequent EE_REMOVEswill wipe previous ones.<p>NB:  submit_ee can ONLY be called from the effect object itself in thecourse of a beginning/handler/end call, or from the effect shadow.",}),"param":({"fun the function to call","interval the interval specifier","flags the flags for the event","event_args additional (optional) args passed to fun",}),"see":({"submit_ee2()","/include/effect.h","add_effect()",}),]),}),"all_expected_ees":({({"varargs","int","*",}),({({"string",}),"func_name",({"int","*",}),"enums",}),(["main":({"Returns the time until the next event that will call func_name.If enums is undefined, the event is searched for in this effect,otherwise the event is searched for in the specified effect(s).This returns the a list of the time in seconds until the functionwill be called in the effect(s) specified.  NB: this is not thetime *between* calls, but the time from Right Now until each call.If no outstanding calls to the function are found, an empty arrayis returned.",}),"see":({"expected_ee()","expected_tt()","submit_ee()",}),"param":({"func_name - the name of the function the ee will call.","enum - the enums of the effect to check in.",}),"return":({"time - array containing the seconds until each outstandingcall to func_name for the effect(s) specified.",}),]),}),"eff_of":({({"string",}),({({"int",}),"enum",}),(["main":({"This method returns the effect object for the given effect number.",}),"see":({"arg_of()","add_effect()","sid_to_enum()",}),"param":({"enum the effect number",}),"return":({"the effect object",}),]),}),"effect_freeze":({({"void",}),({}),(["main":({"This method freezes all the current effects so that they donot continue to be processed.  Basicly it removes the call_outfor the effect_timer().  It also ensures the intrval for theimmediately pending effectis correct.",}),"see":({"effect_timer()","add_effect()",}),]),}),"query_current_effect_enum":({({"int",}),({}),(["main":({"This method returns the current enum.",}),]),}),"effect_unfreeze":({({"void",}),({}),(["main":({"This restarts the internal call_out.",}),"see":({"effects_freeze()","add_effect()",}),]),}),"effects_quiting":({({"void",}),({}),(["main":({"Called when a player actually quits.  Calls the quitting method onall the effects.",}),]),}),"effects_thru_death":({({"void",}),({}),(["main":({"This method removes all the effects as we die.  It calls the functionsurvive_death() on the effect objects themselves to determine ifthey should be kept when the living dies.",}),]),}),"delete_effect":({({"void",}),({({"int",}),"i",}),(["main":({"This removes an effect from the player.  It uses the enum asreturned from sid to enum.  This is the number you see inthe stat of the object next to the effect.",}),"see":({"add_effect()",}),"param":({"i the enum to remove",}),]),}),"expected_ee":({({"varargs","int",}),({({"string",}),"func_name",({"int",}),"enum",}),(["main":({"Returns the time until the next event that will call func_name.If enum is undefined, the event is searched for in this effect,otherwise the event is searched for in the specified effect.If no outstanding calls to the function are found, -1 is returned.",}),"see":({"all_expected_ees()","expected_tt()","submit_ee()",}),"param":({"func_name - the name of the function the ee will call.","enum - the enum of the effect to check in.",}),"return":({"time - the seconds until the next call to func_name forthe effect specified.",}),]),}),"query_logging_effects":({({"int",}),({}),([]),}),"sid_to_enum":({({"int",}),({({"int",}),"sid",}),(["main":({"This method returns the effect number for the given effect id.  Theeffect number is an internal nhandle used by delete_effect()arg_of() set_arg_of() functions.  \"id\" is passed into thebegining/end etc functions on the effect object.",}),"see":({"submit_ee2()","delete_effect()","add_effect()","arg_of()","set_arg_of()",}),"param":({"sid the effect id",}),"return":({"the effect number",}),]),}),"effects_matching":({({"int","*",}),({({"string",}),"eff",}),(["main":({"This method returns an array of effects matching theclassification.  The start part of the classification isused to match, so passing \"npc.\" into this function willmatch all the effects which modify how annpc functions.",}),"see":({"add_effect()",}),"param":({"eff the classification to match",}),"return":({"the array of enums corresponding to the effects",}),]),}),"reset_effects":({({"void",}),({}),(["main":({"This method removes all the current effects off the objectand sets everything back to the initial state.",}),"see":({"add_effect()",}),]),}),"add_effect":({({"void",}),({({"string",}),"eff",({"mixed",}),"arg",}),(["main":({"This method adds an effect onto the object.  RThe arg is passeddirectly onto the function 'begining' on the effectobject.  If the result is non-zero then the returnvalue of the begining function is used instead of thearg and stored away.  If an effect of the sametype is already on the object then the function 'merge_effects'will be called.  If it returns a non-zero value then the arg for theinitial effect will be updated to the new value, otherwise both effectswill runwith different arguments.",}),"see":({"help::effects","submit_ee()",}),]),}),])
protected_functions (["set_effs":({({"void",}),({({"mixed","*",}),"args",}),(["main":({"This method is used to force the effects setup in the object to be aspecified value.  THis is used in the effects effect which sets upeffects on someone using a shadow.  This should only be used on startup.",}),"param":({"args the effects array to overwrite the old one with.",}),]),}),"set_eeq":({({"void",}),({({"mixed","*",}),"args",}),(["main":({"This method is used to force the effects setup in the object to be aspecified value.  THis is used in the effects effect which sets upeffects on someone using a shadow.  This should only be used on startup.",}),"param":({"args the effects array to overwrite the old one with.",}),]),}),])
inherits ([])
main_docs (["main":({"Basic effects module.Extracted from Ember's living effects code by Deutha.",}),"change":({"4-6-1997, Turricanto use arrays of classes, and to allow function pointers.","17-10-1997 Olorinfix a bug then adding an effectin the end() function of another effect.",}),"see":({"help::effects",}),])
define_docs (["EEQ_ARGS":([]),"EEQ_INTERVAL":([]),"EEQ_INCTIME":([]),"EEQ_FUNC":([]),"EFF_ARG":([]),"EFF_SIZE":([]),"EEQ_FLAGS":([]),"EEQ_EFF_OB":([]),"EEQ_SIZE":([]),"EFF_OB_NAME":([]),])
includes (["/include/effect.h":1522061544,])
class_docs (["effect_data":({0,({({"current_enum",({"int",}),}),({"next_id",({"int",}),}),({"next_event_time",({"int",}),}),({"shadows",({"class","effect_shadow","*",}),}),}),(["main":({"This class stores all the data for the effects inheritable.",}),"member":({"current_enum used to keep track of the effect being called;        beginning/end etc.","next_id the next id to assign to an effect","next_event_time when the next effect is due to go off","shadows the shaodws on the object",}),]),}),"effect_event":({0,({({"inctime",({"int",}),}),({"func",({"mixed",}),}),({"eff_ob_num",({"int",}),}),({"interval",({"mixed",}),}),({"flags",({"int",}),}),({"eff_ev_args",({"mixed",}),}),}),([]),}),"effect_shadow":({0,({({"shad_ob",({"object",}),}),({"idnum",({"int",}),}),}),([]),}),])
file_name "/std/basic/effects.c"
last_changed 1522061544
