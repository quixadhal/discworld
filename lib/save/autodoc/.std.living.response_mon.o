#/obj/handlers/autodoc/autodoc_file.c
public_functions (["set_response_mon_regexp":({({"void",}),({({"int",}),"flag",}),(["main":({"This method sets or clears the flag to use regular expressions instead ofthe traditional arrays of words.  In addition, this flag inhibitsthe usual stripping of non-alphanumerics from the input strings.",}),"param":({"flag the new value of the flag: 1 says to use regular expressions,0 to not use them",}),]),}),"query_respond_to_with":({({"mixed","*",}),({}),(["main":({"This method returns the current responding to with array.The array is of the formant:<pre>  ({     trigger1,     response1,     trigger2,     response2,     ...   })</pre>",}),"see":({"add_respond_to_with()",}),]),}),"add_respond_to_with":({({"void",}),({({"mixed","*",}),"trigger",({"mixed",}),"response",}),(["main":({"This method adds a respond message to respond to into thecurrent array of responses.<p>If response_mon_regexp is not set, the trigger consists of anarray of words to be matched(in order) in the string.  If there is an array instead ofa single word at one point then any of the words in thearray will be matched.  If response_mon_regexp is set, thetrigger is a single string, representing the regular expressionto be matched in the string.<p>The response is either an array of things to execute(in which case a random one will be chosen each time) ora function pointer or a string.  If it is a string thenthe command of that name will be executed, if thestring starts with a '#' then the function named after thatwill be called on the npc.  That was exciting wasn't it?If the string has a $hname$ name in it and it is not afunction call (starts with a #) then the $hname$ will be replacedwith the name of the triggering object. $hcname$ or $short$ will bereplaced with the short of the triggering object.<p>In the case of a function call, two arguments are passed intothe function: the first is the person which triggered the effectand the second in the message which triggered the effect.<p>NOTE: The NPC must explicitly know the language being spoken, evenif it's \"common\".  I don't know why.  That's just the way it is.  Seeadd_language().",}),"see":({"query_respond_to_with()","query_response_allowed()","set_response_mon_regexp()","query_response_mon_regexp()","regexp()","add_language()",}),"param":({"trigger the trigger to trigger the action on","response the response to the action",}),"example":({"// Simple responseadd_respond_to_with(({ \"@say\", \"bing\" }), \"'Yes!  Bing bing bing!\");","// respond to someone saying 'frog' or 'toad'add_respond_to_with(({ \"@say\", ({ \"frog\", \"toad\" }) }),                    \"'Frogs and toads are nice.\");","// Randomly say something or bing back at themadd_respond_to_with(({ \"@say\", \"bing\" }),                    ({ \"'Yes!  Bing bing bing!\", \"bing $hname$\" }));","// Call the function 'rabbit' on the npc.add_respond_to_with(({ \"@say\", \"bing\" }), \"#rabbit\");","// Do something cute with a function pointeradd_respond_to_with(({ \"@bing\" }),                 (: do_command(\"'something wild for \" + $1->a_short()) :));",}),]),}),"event_person_sayto":({({"void",}),({({"object",}),"per",({"string",}),"mess",({"string",}),"lang",({"object","*",}),"targets",}),(["main":({"This method is called on the npcs to help in recognising saytos.Beware...  A @say message will also be added, so you need to make sureyou respond to the correct message and not to both.",}),]),}),"query_stop_responding":({({"int",}),({}),(["main":({"This method returns the flag determining the toggling of the responsesof the npc.If this is set to 1, then the npc will stop responding tomessages.",}),"see":({"query_stop_responding()",}),"return":({"1 to the npc will not respond, 0 it is responding",}),]),}),"set_response_mon_debug_mode":({({"void",}),({({"int",}),"flag",}),(["main":({"This method sets the current debug flag for the response monstercode.",}),"see":({"query_response_mon_debug_mode()",}),"param":({"flag the new value of the flag, 1 on, 0 off",}),]),}),"query_only_respond_to":({({"object","*",}),({}),(["main":({"This method returns the current list of people we are only respondingto.",}),"return":({"the array of people we are responding to",}),]),}),"remove_only_respond_to":({({"void",}),({({"object",}),"person",}),(["main":({"This method removes an object from the list of people to respond to.",}),"param":({"person the person to remove",}),]),}),"query_response_allowed":({({"int",}),({({"object",}),"ob",({"string","*",}),"response",}),(["main":({"This method checks to see if the response is allowed for this object.NB: objects to which this_object is not visible are disallowed.",}),"param":({"ob the object to check","response the response that is matched",}),"return":({"1 if the object is allowed, 0 if it is not",}),]),}),"query_response_mon_regexp":({({"int",}),({}),(["main":({"This method returns the current state of the flag that indicates whetherto use regular expressions instead of the traditional array of words.",}),"return":({"1 if using regular expressions, 0 if not",}),]),}),"add_only_respond_to":({({"void",}),({({"object",}),"person",}),(["main":({"This adds an object into the list of objects that we will only respondto.  If this array is empty then we will respond to anyone, if it hassomething in it then we will only respond to them.",}),"param":({"person the person to add to the response array",}),]),}),"set_respond_to_with":({({"void",}),({({"mixed",}),"map",}),(["main":({"This method sets the current responses for the npc.This will overwrite the current responses in the npc.Please use add_respond_to_with in your NPC's instead of this functioncall, as it requires prior knowledge as to the internal structure ofthe respond_to_with code that add_respond_to_with handles nicely.The array is of the formant:<pre>  ({     trigger1,     response1,     trigger2,     response2,     ...   })</pre>",}),"see":({"add_respond_to_with()","query_respond_to_with()",}),]),}),"query_response_mon_debug_mode":({({"int",}),({}),(["main":({"This method checks to see if the response monster code is indebug mode.",}),"see":({"set_response_mon_debug_mode()",}),"return":({"1 if in debug mode, 0 if not",}),]),}),"set_response_mon_understand_anything":({({"void",}),({({"int",}),"flag",}),(["main":({"This method sets or clears the flag that allows the npc to understandany language at all.  THis is useful for those times when you need annpc that speaks/understands any language.",}),"param":({"flag the new value of the flag",}),]),}),"set_stop_responding":({({"void",}),({({"int",}),"i",}),(["main":({"This method allows the toggling of the responses of the npc.If this is set to 1, then the npc will stop responding tomessages.",}),"see":({"query_stop_responding()",}),"param":({"i 1 to make the npc not respond, 0 to make it respond again",}),]),}),])
protected_functions (["check_sub_sequence":({({"mixed","*",}),({({"mixed","*",}),"words",}),(["main":({"This method checks the subsequence of words to see if it matchesany of our current response sets.",}),"see":({"add_respond_to_with()",}),"param":({"words the words which are to be tested",}),"return":({"the response to be executed",}),]),}),"exec_response":({({"void",}),({({"mixed",}),"rep",({"object",}),"per",({"string",}),"mess",}),(["main":({"This method executes the response to the matched string.",}),"see":({"add_respond_to_with()",}),"param":({"rep the response to execute","per the person who initiated the event","mess the message that was matched",}),]),}),"senddstr":({({"void",}),({({"string",}),"str",({"object",}),"per",}),(["main":({"This method runs the command passed in, doing some substitution.",}),"param":({"str the string to execute","per the person who triggered the command",}),]),}),"remove_read_marks":({({"string",}),({({"string",}),"str",}),(["main":({"This method removes annoying read marks to make the string easier toparse.  Basically it strips puncutation.",}),"param":({"str the string to remove the punctuation from",}),"return":({"the string without any punctuation",}),]),}),])
inherits ([])
main_docs (["main":({"This file contains the methods to make the npcs in game respondto soul and says.  Allows for a level of npc interation.<p>Code originaly by nimmox@igor.  Modified for discworld by Pinkfish.<p>",}),"author":({"Pinkfish",}),"change":({"Olorin Sep 97event_soul does a convert_message on the mess first,to avoid spurious matches caused by a message like eg.\"$the_short:/global/lord#64387$ $V$0=smiles,smile$V$ .... in souln","who knows whenchanged to stop the responses when the npc is in /room/rubbish",}),"see":({"/obj/monster.c",}),])
define_docs (["SPECIAL_DAY":([]),])
includes (["/include/language.h":1522061544,"/include/soul.h":1522061544,])
class_docs (["response_data":({0,({({"last_ob",({"object",}),}),({"last_mess",({"string",}),}),({"stop_responding",({"int",}),}),({"use_regexp",({"int",}),}),({"last_count",({"int",}),}),({"last_time",({"int",}),}),({"understand_anything",({"int",}),}),({"only_respond_to",({"object","*",}),}),}),([]),}),])
file_name "/std/living/response_mon.c"
last_changed 1522061544
