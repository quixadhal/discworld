#/obj/handlers/autodoc/autodoc_file.c
public_functions (["query_expression_string":({({"string",}),({({"class","parse_node","*",}),"expr",({"int",}),"brief",}),(["main":({"This method returns the expresion as a string.",}),"param":({"expr the expression","brief don't expand the variable names",}),"return":({"the expression as a string",}),]),}),"parse_integer_string":({({"class","parse_node","*",}),({({"string",}),"str",}),(["main":({"A very small recursive decent parser which must return a integervalue.",}),"param":({"str the input string",}),"return":({"the array control structure",}),]),}),"query_user_function_arg_types":({({"mixed","*",}),({({"string",}),"name",}),(["main":({"This method returns the argument names types of the user definedfunction. ",}),"param":({"name the name of the function to lookup",}),"return":({"information on the arguments, 0 on failure",}),]),}),"query_null_type":({({"class","parse_node",}),({({"int",}),"type",}),(["main":({"This method returns a null object of the specified type.",}),"param":({"type the type to get the null object of",}),"return":({"the null object",}),]),}),"query_operator_name":({({"string",}),({({"int",}),"operator",}),(["main":({"This method returns the string value of the operator name.",}),"param":({"operator the operator name to return",}),"return":({"the string name of the operator",}),]),}),"add_allowed_variable":({({"void",}),({({"string",}),"name",({"int",}),"type",({"function",}),"value",}),(["main":({"This method adds in an allowed variable and specifies it's type.",}),"param":({"name the name of the variable","type the type of the variable","value the value of the variable",}),]),}),"query_function_names":({({"string","*",}),({}),(["main":({"This method returns all the function names defined in this expressioninheritable.",}),"return":({"the function names",}),]),}),"parse_boolean_string":({({"class","parse_node","*",}),({({"string",}),"str",}),(["main":({"A very small recursive decent parser which must return a booleanvalue.",}),"param":({"str the input string",}),"return":({"the array control structure",}),]),}),"query_variable_type":({({"int",}),({({"string",}),"name",}),(["main":({"This method returns the type of the variable.",}),"param":({"name the name of the variable to check",}),"return":({"the type of the variable, EXPRESSION_TYPE_ERROR if there is novariable",}),]),}),"evaluate_expression":({({"class","parse_node",}),({({"class","parse_node","*",}),"expr",({"mixed","args",}),"...",}),(["main":({"This method evaluates the expression and creates a nice end resultthingy.",}),"param":({"expr the exrpession to evaluate","args the optional args parsed into the various function calls",}),"return":({"the type and value of the expression, 0 if failed",}),]),}),"query_user_function_arg_names":({({"mixed","*",}),({({"string",}),"name",}),(["main":({"This method returns the argument names names of the user definedfunction. ",}),"param":({"name the name of the function to lookup",}),"return":({"information on the arguments, 0 on failure",}),]),}),"add_allowed_function":({({"void",}),({({"string",}),"name",({"int",}),"type",({"int","*",}),"args",({"function",}),"value",}),(["main":({"This method adds in an allowed function and specifies the types ittakes.",}),"param":({"name the name of the function","type the return type of the function","args the types of the arguements (an array)","value the function to call to get the value",}),]),}),"query_type_name":({({"string",}),({({"int",}),"type",}),(["main":({"This method returns the name of the type.",}),"param":({"type the type to get the string name of",}),"return":({"the string name of the type",}),]),}),"query_variable_value":({({"function",}),({({"string",}),"name",}),(["main":({"This method returns the value of the variable.",}),"param":({"name the name of the variable to find",}),"return":({"the value of the variable, 0 if not found",}),]),}),"query_last_expression_warning":({({"string",}),({}),(["main":({"This method returns the last warning if there was an warning in the parsing.",}),"return":({"the last warning",}),]),}),"parse_money_string":({({"class","parse_node","*",}),({({"string",}),"str",}),(["main":({"A very small recursive decent parser which must return a moneyvalue.",}),"param":({"str the input string",}),"return":({"the array control structure",}),]),}),"query_function_type":({({"int",}),({({"string",}),"name",}),(["main":({"This method returns the type of the function.",}),"param":({"name the name of the function to check",}),"return":({"the type of the function, EXPRESSION_TYPE_ERROR if there is nofunction",}),]),}),"query_user_function_string":({({"string",}),({({"string",}),"func",}),(["main":({"This method makes a nice string representation of the user function.",}),"param":({"func the name of the user function to get a string of",}),"return":({"the user function string",}),]),}),"query_last_expression_error":({({"string",}),({}),(["main":({"This method returns the last error if there was an error in the parsing.",}),"return":({"the last error",}),]),}),"query_function_variable_position":({({"int",}),({({"string",}),"name",}),(["main":({"This method returns the position of the function variable.",}),"param":({"name the name of the function variable to check",}),"return":({"the type of the variable, EXPRESSION_TYPE_ERROR if there is novariable",}),]),}),"query_function_value":({({"function",}),({({"string",}),"name",}),(["main":({"This method returns the value of the function.",}),"param":({"name the name of the function to find",}),"return":({"the value of the function, 0 if not found",}),]),}),"sizeof_function":({({"int",}),({({"mixed","*",}),"arr",({"mixed","args",}),"...",}),(["main":({"Does a sizeof an array.  Nifty...",}),"param":({"arr the array to get the sizeof","args the rest of the arguments",}),"return":({"the sizeof the array",}),]),}),"query_user_function_args":({({"mixed","*",}),({({"string",}),"name",}),(["main":({"This method returns the argument names and types of the user definedfunction.  It returns an array of two elements, the first is anarray of names and the second is an array of types.",}),"param":({"args the arguments to return",}),"return":({"information on the arguments, 0 on failure",}),]),}),"query_function_variable_type":({({"int",}),({({"string",}),"name",}),(["main":({"This method returns the type of the function variable.",}),"param":({"name the name of the function variable to check",}),"return":({"the type of the variable, EXPRESSION_TYPE_ERROR if there is novariable",}),]),}),"parse_user_expression":({({"string",}),({({"string",}),"def",({"string",}),"str",}),(["main":({"This method attempts to parse a user expression.",}),"param":({"name the name of the function","args the name and types of the arguments","str the input string",}),"return":({"the name of the function, 0 on failure",}),]),}),"remove_user_expression":({({"int",}),({({"string",}),"name",}),(["main":({"This method removes the currently defined user expression.",}),"param":({"name the expression to remove",}),]),}),"query_user_function_return_type":({({"int",}),({({"string",}),"name",}),(["main":({"This method returns the return type of the user defined function.",}),"return":({"the return type, EXPRESSION_TYPE_ERROR on error",}),]),}),"parse_user_expression_definition":({({"mixed","*",}),({({"string",}),"def",}),(["main":({"This will pass the arguments to a user defined function and returnan array of three elements.  The first is the name of the function,the second is the array of arguments types and the third is the array ofargument names.",}),]),}),"query_user_function_expression":({({"class","parse_node","*",}),({({"string",}),"name",}),(["main":({"This method returns the expression of the user defined function.",}),"param":({"name the name of the function to look up",}),"return":({"the expression of the user defined function",}),]),}),"query_type_value":({({"int",}),({({"string",}),"type",}),(["main":({"This method returns the value of the type.",}),"param":({"type the type to get the integer value of",}),"return":({"the integer value of the type",}),]),}),"query_function_args_types":({({"int","*",}),({({"string",}),"name",}),(["main":({"This method returns the type of the function.",}),"param":({"name the name of the function to check",}),"return":({"the args of the function, null array is not found",}),]),}),"query_variable_names":({({"string","*",}),({}),(["main":({"This method returns the names of all the variables.",}),"return":({"all the variable names",}),]),}),"query_user_function_names":({({"string","*",}),({}),(["main":({"This method returns the list of user defined functions in theinheritable.",}),"return":({"the list of user defined functions",}),]),}),])
protected_functions (["is_array_type":({({"int",}),({({"int",}),"type",}),(["main":({"This checks to make sure that the type is an array.",}),"param":({"type the type to check",}),"return":({"1 if it is an array, 0 if not",}),]),}),"query_token":({({"string","*",}),({({"string",}),"str",}),(["main":({"This method find the next token.  It can be overrideen in higher thingsto deal with special token types (ie: money).",}),"param":({"str the input string",}),"return":({"({ token, rest })",}),]),}),"is_space":({({"int",}),({({"int",}),"space",}),(["main":({"This method checks to see if the passed in character is a space ora space equivilant.",}),"param":({"space the character to check",}),"return":({"1 if it is a space, 0 if not",}),]),}),"is_null_array_type":({({"int",}),({({"int",}),"type",}),(["main":({"This checks to make sure that the type is a null array.",}),"param":({"type the type to check",}),"return":({"1 if it is a null array, 0 if not",}),]),}),"is_number_type":({({"int",}),({({"int",}),"type",}),(["main":({"This checks to make sure that the type is a number based type.This can be controlled to make sure that any added types are alsoallowed to be treated as numbers.",}),"param":({"type the type to check",}),"return":({"1 if it is a number, 0 if not",}),]),}),"is_alpha":({({"int",}),({({"int",}),"alpha",}),(["main":({"This method checks to see if the passed in character is an alphaor not.",}),"param":({"alpha the character to check",}),"return":({"1 if it alpha, 0 if not",}),]),}),"is_number":({({"int",}),({({"int",}),"number",}),(["main":({"This method checks to see if the passed in character is a numberor not.",}),"param":({"number the character to check",}),"return":({"1 if it is a number, 0 if not",}),]),}),])
inherits ([])
main_docs (["main":({"This is an inheritable to handle certain sorts of expressions in stuff.These expression can be setup by players (or creators) and then runor evaluated.  It allows controlling the types usable by the expressionhandlers, strings, arrays, mappings, integers and floats.",}),"started":({"Thu May  4 22:44:34 PDT 2000",}),"author":({"Pinkfish",}),])
define_docs (["EXPRESSION_ARRAY_DEREFERENCE":([]),"EXPRESSION_IF_NEW":([]),"EXPRESSION_GREATOR_THAN":([]),"EXPRESSION_ARRAY_AGGREGATE":([]),"EXPRESSION_PLUS":([]),"EXPRESSION_MINUS":([]),"EXPRESSION_AND":([]),"EXPRESSION_FUNC_VAR_POS":([]),"EXPRESSION_OR":([]),"EXPRESSION_FUNC_VAR_NAME":([]),"EXPRESSION_FUNC_NO_ARGS":([]),"EXPRESSION_TRUE":([]),"EXPRESSION_NOT":([]),"EXPRESSION_MULTIPLY":([]),"EXPRESSION_FALSE":([]),"EXPRESSION_DIVIDE":([]),"EXPRESSION_IF":([]),"EXPRESSION_GREATOR_OR_EQUAL":([]),"EXPRESSION_TYPE":([]),"EXPRESSION_NOT_EQUAL_TO":([]),"EXPRESSION_EQUAL_TO":([]),"EXPRESSION_PARSE_STRING":([]),"EXPRESSION_AND_NEW":([]),"EXPRESSION_OR_NEW":([]),"EXPRESSION_FUNC_NAME":([]),"EXPRESSION_TREE":([]),"EXPRESSION_LESS_OR_EQUAL":([]),"EXPRESSION_LESS_THAN":([]),])
includes (["/include/shops/bank.h":1522061544,"/include/expressions.h":1522061544,"/include/money.h":1522061544,])
class_docs (["function_thing":({0,({({"type",({"int",}),}),({"value",({"function",}),}),({"args",({"int","*",}),}),({"return_pos",({"int",}),}),}),([]),}),"variable_thing":({0,({({"type",({"int",}),}),({"value",({"function",}),}),}),([]),}),"func_variable_thing":({0,({({"type",({"int",}),}),({"arg_no",({"int",}),}),}),([]),}),"user_function_thing":({0,({({"type",({"int",}),}),({"expr",({"class","parse_node","*",}),}),({"arg_types",({"int","*",}),}),({"arg_names",({"string","*",}),}),}),([]),}),])
file_name "/std/basic/expressions.c"
last_changed 1522061544
